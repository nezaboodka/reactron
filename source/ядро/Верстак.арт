// The below copyright notice and the license permission notice
// shall be included in all copies or substantial portions.
// Copyright (C) 2019-2022 Nezaboodka Software <contact@nezaboodka.com>
// License: https://raw.githubusercontent.com/nezaboodka/verstak/master/LICENSE
// By contributing, you agree that your contributions will be
// automatically licensed under the license referred above.

// import { reactive, nonreactive, Transaction, options, Reentrance, Rx, LoggingOptions, Collection, Item, ObservableObject, raw, MemberOptions } from "reactronic"
// import { CellRange, Layout, Priority, Режим, Align, BlockArea, КонструкторБлока, Блок, Driver, ПростойДелегат, БлокDescriptor, БлокCtx } from "./Interfaces"
// import { emitLetters, equalCellRanges, parseCellRange, getCallerInfo } from "./Utils"

используется артель

// Verstak

тип Verstak = ссылка на объект
{
  общее постоянное shortFrameDuration = 16 // ms
  общее постоянное longFrameDuration = 300 // ms
  общее currentRenderingPriority = Приоритет.высокий
  общее frameDuration = Verstak.longFrameDuration

  общая
  операция заявить<T = Ничего, M = Значение, C = Значение, R = Ничего>(
    драйвер: Драйвер<T, C>, конструктор: КонструкторБлока<T, M, C, R>?,
    оригинал: КонструкторБлока<T, M, C, R>?): Блок<T, M, C, R>
  {
    // Нормализация аргументов
    если конструктор тогда
      конструктор.оригинал = оригинал
    else
      конструктор = оригинал ?? []
    пусть код = конструктор.код
    пусть владелец = gCurrent?.элемент
    если владелец тогда
    {
      // Check for coalescing separators or lookup for existing block
      пусть пре: Item<XBlock<Значение, Значение, Значение, Значение>>? = пусто
      пусть дети = владелец.дескриптор.дети
      если драйвер.это-строка тогда
      {
        пусть последний = дети.lastClaimedItem()
        если последний?.элемент?.дескриптор.драйвер == драйвер тогда
          пре = последний
      }
      // ex ??= дети.claim(
      //   key = код || generateKey(владелец), undefined,
      //   "nested blocks can be declared inside render function only")
      если пре == пусто тогда
      {
        если код == пусто или код == "" тогда
          код = сгенерировать-код(владелец)
        пре = дети.claim(код, пусто, "nested blocks can be declared inside render function only")
      }
      // Reuse existing block or claim a new one
      если пре тогда
      {
        // Reuse existing block
        результат = пре.элемент
        пусть д = результат.дескриптор
        if д.драйвер != драйвер и драйвер != пусто тогда
          ошибка "changing block драйвер is not yet supported: \"{ результат.дескриптор.драйвер.name }\" -> \"{ драйвер?.nam.это-строка
        пусть exTriggers = д.конструктор.триггеры
        if triggersAreEqual(конструктор.триггеры, exTriggers) тогда
          конструктор.триггеры = exTriggers // preserve триггеры instance
        д.конструктор = конструктор
      }
      иначе
      {
        // Create new block
        результат = XBlock<T, M, C, R>(
          код ? (код != пусто и код != "") | сгенерировать-код(владелец),
          драйвер, владелец, конструктор)
        результат.дескриптор.экземпляр = дети.add(результат)
      }
    }
    иначе
    {
      // Create new root block
      результат = XBlock<T, M, C, R>(код ?? "", драйвер, владелец, конструктор)
      результат.дескриптор.экземпляр = Collection.createItem(результат)
      triggerRendering(результат.дескриптор.экземпляр)
    }
  }

  // static get block(): Блок {
  //   if (gCurrent == undefined)
  //     throw new Error("current block is undefined")
  //   return gCurrent.instance
  // }

  общая
  операция renderNestedTreesThenDo(action: операция(о: Ошибка))
  {
    runRenderNestedTreesThenDo(пусто, action)
  }

  общая
  операция getDefaultLoggingOptions(): LoggingOptions?
  {
    return XBlock.logging
  }

  общая
  операция setDefaultLoggingOptions(logging: LoggingOptions?)
  {
    XBlock.logging = logging
  }
}

// БазовыйДрайвер

тип БазовыйДрайвер<T, C = Значение> = ссылка на объект
на основе Драйвер<T, C>
{
  общее постоянное фрагмент = БазовыйДрайвер<Значение, Значение>(
    "фрагмент", нет, { b.childrenLayout = Layout.Group })

  имя: Текст
  это-строка: Булево
  преднастройка: ПростойДелегат<T>?

  при создании(
    имя`: Текст,
    это-строка`: Булево,
    преднастройка`: ПростойДелегат<T>?)
  {
    имя = имя`
    это-строка = это-строка`
    преднастройка = преднастройка`
  }

  операция заявить(блок: Блок<T, Значение, C, Ничего>)
  {
    пусть б = блок как XBlock<T, Значение, C, Ничего>
    chainedClaim(б, б.дескриптор.конструктор)
  }

  подмена
  операция create(block: Блок<T, Значение, C, Ничего>, b: объект { native: T?; controller: C? })
  {
    chainedCreate(block, block.дескриптор.конструктор)
  }

  подмена
  операция initialize(block: Блок<T, Значение, C, Ничего>)
  {
    пусть б = block как XBlock<T, Значение, C, Ничего>
    если preset тогда
      preset(б)
    chainedInitialize(б, б.дескриптор.конструктор)
  }

  подмена
  операция mount(block: Блок<T, Значение, C, Ничего>)
  {
    // nothing to do by default
  }

  подмена
  операция render(block: Блок<T, Значение, C, Ничего>)
  {
    chainedRender(block, block.дескриптор.конструктор)
  }

  подмена
  операция finalize(block: Блок<T, Значение, C, Ничего>, isLeader: Булево): Булево
  {
    пусть б = block as XBlock<T, Значение, C, Ничего>
    chainedFinalize(б, б.дескриптор.конструктор)
    return isLeader // treat children as finalization leaders as well
  }

  подмена
  операция applyChildrenLayout(block: Блок<T, Значение, C, Значение>, value: Layout)
  {
    // do nothing
  }

  подмена
  операция applyCellRange(block: Блок<T, Значение, C, Значение>, value: CellRange?)
  {
    // do nothing
  }

  подмена
  операция applyWidthGrowth(block: Блок<T, Значение, C, Значение>, value: Число)
  {
    // do nothing
  }

  подмена
  операция applyMinWidth(block: Блок<T, Значение, C, Значение>, value: Текст)
  {
    // do nothing
  }

  подмена
  операция applyMaxWidth(block: Блок<T, Значение, C, Значение>, value: Текст)
  {
    // do nothing
  }

  подмена
  операция applyHeightGrowth(block: Блок<T, Значение, C, Значение>, value: Число)
  {
    // do nothing
  }

  подмена
  операция applyMinHeight(block: Блок<T, Значение, C, Значение>, value: Текст)
  {
    // do nothing
  }

  подмена
  операция applyMaxHeight(block: Блок<T, Значение, C, Значение>, value: Текст)
  {
    // do nothing
  }

  подмена
  операция applyContentAlignment(block: Блок<T, Значение, C, Значение>, value: Align)
  {
    // do nothing
  }

  подмена
  операция applyBlockAlignment(block: Блок<T, Значение, C, Значение>, value: Align)
  {
    // do nothing
  }

  подмена
  операция applyContentWrapping(block: Блок<T, Значение, C, Значение>, value: Булево)
  {
    // do nothing
  }

  подмена
  операция applyOverlayVisible(block: Блок<T, Значение, C, Значение>, value: Булево?)
  {
    // do nothing
  }

  подмена
  операция applyStyle(block: Блок<T, Значение, C, Значение>, secondary: Булево, styleName: string, enabled: Булево?)
  {
    // do nothing
  }
}

// Utils

скрытая
операция сгенерировать-код(владелец: XBlock<Значение, Значение, Значение, Значение>): Текст
{
  владелец.дескриптор.номер += 1
  пусть номер = владелец.дескриптор.номер
  пусть буквы = emitLetters(номер)
  если Rx.isLogging тогда
    result = "·{ getCallerInfo(буквы) }"
  иначе
    result = "·{ буквы }"
}

скрытая
операция chainedMode(конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>?): Режим
{
  return конструктор?.modes ?? (? конструктор?.original : chainedMode(конструктор?.original) | Режим.Default)
}

скрытая
операция chainedClaim(блок: Блок<Значение, Значение, Значение, Значение>,
  конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>)
{
  пусть заявить = конструктор.заявить
  пусть оригинал = конструктор.оригинал
  если заявить тогда
    заявить(блок, ? оригинал : { chainedClaim(блок, оригинал) } | NOP)
  иначе если оригинал тогда
    chainedClaim(блок, оригинал)
}

скрытая
операция chainedCreate(блок: Блок<Значение, Значение, Значение, Значение>,
  конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>)
{
  пусть создать = конструктор.создать
  пусть оригинал = конструктор.оригинал
  если создать тогда
    создать(блок, ? оригинал : { chainedCreate(блок, оригинал) } | NOP)
  иначе если оригинал тогда
    chainedCreate(блок, оригинал)
}

скрытая
операция chainedInitialize(блок: Блок<Значение, Значение, Значение, Значение>,
  конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>)
{
  пусть подготовить = конструктор.подготовить
  пусть оригинал = конструктор.оригинал
  если подготовить тогда
    подготовить(блок, ? оригинал : { chainedInitialize(блок, оригинал) } | NOP)
  иначе если оригинал тогда
    chainedInitialize(блок, оригинал)
}

скрытая
операция chainedRender(блок: Блок<Значение, Значение, Значение, Значение>,
  конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>)
{
  пусть показать = конструктор.показать
  пусть оригинал = конструктор.оригинал
  если показать тогда
    показать(блок, ? оригинал : { chainedRender(блок, оригинал) } | NOP)
  иначе если оригинал тогда
    chainedRender(блок, оригинал)
}

скрытая
операция chainedFinalize(блок: Блок<Значение, Значение, Значение, Значение>,
  конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>)
{
  пусть завершить = конструктор.завершить
  пусть оригинал = конструктор.оригинал
  если завершить тогда
    завершить(блок, ? оригинал : { chainedFinalize(блок, оригинал) } | NOP)
  иначе если оригинал тогда
    chainedFinalize(блок, оригинал)
}

тип StaticDriver<T> = ссылка на объект
на основе БазовыйДрайвер<T>
{
  постоянный элемент: T

  при создании(элемент`: T, имя: Текст,
    это-строка: Булево, преднастройка: ПростойДелегат<T>?)
  {
    основа(имя, это-строка, преднастройка)
    элемент = элемент`
  }

  подмена
  операция создать(block: Блок<T, Значение, Значение, Ничего>,
    b: объект { native: T?; controller: Значение? })
  {
    b.native = элемент
  }
}

// CursorCommandDriver

тип CursorCommand = ссылка на объект
{
  absolute: Текст?
  columnShift: Целое?
  rowShift: Целое?
}

тип CursorCommandDriver = ссылка на объект
на основе БазовыйДрайвер<CursorCommand, Ничего>
{
  при создании()
  {
    основа("курсор", нет, { b.childrenLayout = Layout.Cursor })
  }

  подмена
  операция создать(блок: Блок<CursorCommand, Значение, Ничего, Ничего>,
    б: объект { native: CursorCommand?; controller: Значение? })
  {
    б.native = CursorCommand()
    основа(блок, б)
  }
}

// ContextVariable

тип ContextVariable<T: Объект = Объект> = ссылка на объект
{
  постоянное defaultValue: T?

  при создании(defaultValue`: T?)
  {
    defaultValue = defaultValue`
  }

  // set value(value: T)
  // {
  //   XBlock.setContextVariableValue(объект, значение)
  // }

  // get value(): T
  // {
  //   return XBlock.useContextVariableValue(this)
  // }

  // get valueOrUndefined(): T | undefined
  // {
  //   return XBlock.tryUseContextVariable(this)
  // }
}

// XBlock

тип CursorPosition = ссылка на объект
{
  x: Целое
  y: Целое
  runningMaxX: Целое
  runningMaxY: Целое
  flags: CursorFlags

  при создании(пре: CursorPosition) {
    x = пре.x
    y = пре.y
    runningMaxX = пре.runningMaxX
    runningMaxY = пре.runningMaxY
    flags = порязрядное-и(пре.flags, поразрядное-не(CursorFlags.OwnCursorPosition))
  }
}

тип CursorFlags = вариант
{
  не-задано = 0
  независимость-от-курсора = 1
  зависимость-от-нарастающей-ширины = 2
  зависимость-от-нарастающей-высоты = 4
}

постоянное UndefinedCellRange = Объект.freeze([ x1 = 0, y1 = 0, x2 = 0, y2 = 0 ])
постоянное InitialCursorPosition: CursorPosition = Object.freeze(CursorPosition([ x = 1, y = 1, runningMaxX = 0, runningMaxY = 0, flags = CursorFlags.None ]))

тип XBlockCtx<T: Объект = Объект> = ссылка на объект
на основе ObservableObject, БлокCtx<T>
{
  #raw next: XBlockCtx<Объект>?
  #raw variable: ContextVariable<T>
  value: T

  при создании(variable: ContextVariable<T>, value: T) {
    основа()
    next = пусто
    variable = variable
    value = value
  }
}

тип XBlockDescriptor<T = Значение, M = Значение, C = Значение, R = Ничего> = ссылка на объект
на основе ДескрипторБлока<T, M, C, R>
{
  постоянный код: Текст
  постоянный драйвер: Драйвер<T, C>
  конструктор: КонструкторБлока<T, M, C, R>
  постоянный уровень: Целое
  постоянный владелец: XBlock<Значение, Значение, Значение, Значение>
  хостер: XBlock<Значение, Значение, Значение, Значение>
  постоянное дети: Collection<XBlock<Значение, Значение, Значение, Значение>>
  item: Item<XBlock<Значение, Значение, Значение, Значение>>?
  штапм: Целое
  outer: XBlock<Значение, Значение, Значение, Значение>
  контекст: XBlockCtx<Значение>?
  номер: Целое
  maxColumnCount: Целое = 0
  maxRowCount: Целое = 0
  cursorPosition: CursorPosition?

  при создании(код`: Текст, драйвер`: Драйвер<T, C>,
    конструктор`: Readonly<КонструкторБлока<T, M, C, R>>,
    блок: XBlock<T, M, C, R>, владелец`: XBlock<Значение, Значение, Значение, Значение>?)
  {
    код = код`
    драйвер = драйвер`
    конструктор = конструктор`
    если владелец` тогда
    {
      пусть д = владелец`.дескриптор
      уровень = д.уровень + 1
      владелец = владелец`
      outer = владелец` ? д.контекст | д.outer
    }
    иначе
    {
      уровень = 1
      владелец` = блок
      владелец = блок
      outer = блок
    }
    хостер = блок // block is unmounted
    дети = Collection<XBlock<Значение, Значение, Значение, Значение>>(взять-код-блока, да)
    item = пусто
    штамп = 0
    контекст = пусто
    номер = 0
    maxColumnCount = 0
    maxRowCount = 0
    cursorPosition = пусто
  }
}

тип XBlock<T = Значение, M = Значение, C = Значение, R = Значение> = ссылка на объект
на основе Блок<T, M, C, R>
{
  // Static properties
  общее grandCount: Целое = 0
  общее disposableCount: Целое = 0
  общее logging: НастройкиЖурнализации? = пусто

  // System-managed properties
  охраняемое типом дескриптор: XBlockDescriptor<T, M, C, R>
  реализация: T

  // User-defined properties
  модель: M
  контролер: C
  // _childrenLayout: Раскладка
  // _area: ОбластьБлока
  // скрытое _cellRange: Рамка
  // скрытое _widthGrowth: Число
  // скрытое _minWidth: Текст
  // скрытое _maxWidth: Текст
  // скрытое _heightGrowth: Число
  // скрытое _minHeight: Текст
  // скрытое _maxHeight: Текст
  // скрытое _contentAlignment: Align
  // скрытое _blockAlignment: Align
  // скрытое _contentWrapping: Булево
  // скрытое _overlayVisible: Булево?
  hasStyles: Булево
  childrenShuffling: Булево
  renderingPriority: Приоритет

  при создании(код`: Текст, драйвер`: Драйвер<T, C>,
    владелец`: XBlock<Значение, Значение, Значение, Значение>?,
    конструктор: КонструкторБлока<T, M, C, R>)
  {
    // System-managed properties
    дескриптор = XBlockDescriptor(код`, драйвер`, конструктор, объект, владелец`)
    реализация = пусто как Значение как T // hack
    // User-defined properties
    модель = пусто как Значени
    контролер = пусто как Значение как C // hack
    // _childrenLayout = Layout.Row
    // _area = undefined
    // _cellRange = UndefinedCellRange
    // _widthGrowth = 0
    // _minWidth = ""
    // _maxWidth = ""
    // _heightGrowth = 0
    // _minHeight = ""
    // _maxHeight = ""
    // _contentAlignment = Align.Default
    // _blockAlignment = Align.Default
    // _contentWrapping = нет
    // _overlayVisible = undefined
    hasStyles = нет
    childrenShuffling = нет
    renderingPriority = Priority.Realtime
    // Monitoring
    XBlock.grandCount += 1
    если включен-режим(Режим.SeparateReaction) тогда
      XBlock.disposableCount += 1
  }

  // @reactive
  // @options({
  //   reentrance: Reentrance.CancelPrevious,
  //   triggeringArgs: да,
  //   noSideEffects: нет,
  // })
  реактивная
  операция render(триггеры: Значение) {
    // триггеры parameter is used to enforce rendering by owner
    renderNow(дескриптор.экземпляр!)
  }

  операция включен-режим(mode: Режим): Булево
  {
    результат = поразрядное-и(chainedMode(дескриптор.конструктор), mode) == mode
  }

  охраняемое типом
  isInitialRendering: Булево
    при чтении { результат = дескриптор.штамп == 2 }

  isSequential: Булево
    при чтении { результат = дескриптор.дети.isStrict }
    при записи { дескриптор.дети.isStrict = значение }

  охраняемое типом
  isAuxiliary: Булево
    при чтении { результат = раскладка-детей > Раскладка.заметка } // Row, Group, Cursor

  охраняемое типом
  isBand: Булево
    при чтении { результат = раскладка-детей == Раскладка.лента }

  охраняемое типом
  isTable: Булево
    при чтении { результат = раскладка-детей == Раскладка.таблица }

  охраняемое типом
  isAutoMountEnabled: Булево
    при чтении { return не(has(Режим.ManualMount)) и дескриптор.хостер != объект }

  охраняемое типом
  isMoved: Булево
    при чтении { return дескриптор.владелец.дескриптор.дети.isMoved(дескриптор.экземпляр!) }

  раскладка-детей: Раскладка
    при записи
    {
      если значение != хранимое или дескриптор.штапм < 2 тогда
      {
        дескриптор.драйвер.applyChildrenLayout(объект, значение)
        хранимое = значение
      }
    }

  area: ОбластьБлока
    при записи
    {
      пусть д = дескриптор
      пусть драйвер = д.драйвер
      если не(драйвер.это-строка) тогда
      {
        пусть вд = д.владелец.дескриптор
        пусть cursorPosition = д.экземпляр!.prev?.instance.дескриптор.cursorPosition ?? InitialCursorPosition
        пусть newCursorPosition = ? owner.children.isStrict : CursorPosition(cursorPosition) | пусто
        пусть isCursorBlock = драйвер это CursorCommandDriver
        пусть cellRange = blockAreaToCellRange(не(isCursorBlock),
          значение, вд.maxColumnCount, вд.maxRowCount,
          cursorPosition, newCursorPosition)
        д.cursorPosition = newCursorPosition
        если не(equalCellRanges(cellRange, this._cellRange)) тогда
        {
          драйвер.applyCellRange(объект, cellRange)
          this._cellRange = cellRange
        }
        хранимое = значение ?? { }
      }
      иначе
        rowBreak()
    }

  widthGrowth: Число
    при записи {
      если значение != хранимое тогда
      {
        дескриптор.драйвер.applyWidthGrowth(объект, значение)
        хранимое = значение
      }
    }

  minWidth: Текст
    при записи
    {
      если значение != хранимое тогда
      {
        дескриптор.драйвер.applyMinWidth(объект, значение)
        хранимое = значение
      }
    }

  maxWidth: Текст
   при записи
   {
      если значение != хранимое тогда
      {
        дескриптор.драйвер.applyMaxWidth(объект, значение)
        хранимое = значение
      }
    }

  heightGrowth: Число
    при записи
    {
      если значение != хранимое тогда
      {
        дескриптор.драйвер.applyHeightGrowth(объект, значение)
        хранимое = значение
      }
    }

  minHeight: Текст
    при записи
    {
      если значение != хранимое тогда
      {
        дескриптор.драйвер.applyMinHeight(объект, значение)
        хранимое = значение
      }
    }

  maxHeight: Текст
    при записи
    {
      если значение != хранимое тогда
      {
        дескриптор.драйвер.applyMaxHeight(объект, значение)
        хранимое = значение
      }
   }

  contentAlignment: Выравнивание
    при записи
    {
      если значение != хранимое тогда
      {
        дескриптор.драйвер.applyContentAlignment(объект, значение)
        хранимое = значение
      }
    }

  blockAlignment: Выравнивание
    при записи
    {
      если значение != хранимое тогда
      {
        дескриптор.драйвер.applyBlockAlignment(объект, значение)
        хранимое = значение
      }
    }

  contentWrapping: Булево
    при записи
    {
      если значение != хранимое тогда
      {
        дескриптор.драйвер.applyContentWrapping(объект, значение)
        хранимое = значение
      }
    }

  overlayVisible: Булево?
    при записи
    {
      если значение != хранимое тогда
      {
        дескриптор.драйвер.applyOverlayVisible(объект, значение)
        хранимое = значение
      }
    }

  операция style(styleName: Текст, вкл: Булево?)
  {
    дескриптор.драйвер.applyStyle(объект, hasStyles, styleName, вкл)
    hasStyles = да
  }

  операция configureReactronic(options: Partial<MemberOptions>): MemberOptions
  {
    if дескриптор.stamp != 1 или не(has(Режим.SeparateReaction)) тогда
      ошибка "reactronic can be configured only for blocks with separate reaction mode and only inside initialize"
    return Rx.getController(this.render).configure(options)
  }

  общее
  охраняемое типом
  curr: Item<XBlock>
    при записи
    {
      если не(gCurrent) тогда
        ошибка "current block is undefined"
      результат = gCurrent
    }

  общая
  операция tryUseContextVariable<T: Object>(variable: ContextVariable<T>): T?
  {
    пусть б = XBlock.curr.элемент
    пока б.дескриптор.context?.variable != variable и б.дескриптор.владелец != б выполнить
      б = б.дескриптор.outer
    return б.дескриптор.context?.value это Т? // TODO: to get rid of any
  }

  общая
  операция useContextVariableValue<T: Object>(variable: ContextVariable<T>): T
  {
    результат = XBlock.tryUseContextVariable(variable) ?? variable.defaultValue
    если не(результат) тогда
      ошибка "context doesn't exist"
  }

  общая
  операция setContextVariableValue<T: Object>(variable: ContextVariable<T>, value: T?)
  {
    пусть б = XBlock.curr.элемент
    пусть д = б.дескриптор
    пусть владелец = д.владелец
    пусть hostCtx = nonreactive(владелец.дескриптор.context?.value)
    если value и value != hostCtx тогда
    {
      если hostCtx тогда
        д.outer = владелец
      иначе
        д.outer = владелец.дескриптор.outer
      Transaction.run([ separation = да ],
      {
        постоянное ctx = д.context
        если ctx тогда
        {
          ctx.variable = variable
          ctx.value = value // update context thus invalidate observers
        }
        иначе
          д.context = XBlockCtx<any>(variable, value)
      })
    }
    иначе если hostCtx тогда
      д.outer = владелец
    иначе
      д.outer = владелец.дескриптор.outer
  }

  скрыто
  операция rowBreak()
  {
    пусть д = дескриптор
    пусть cursorPosition = д.экземпляр!.prev?.instance.дескриптор.cursorPosition ?? InitialCursorPosition
    пусть newCursorPosition = CursorPosition(cursorPosition)
    дескриптор.cursorPosition = newCursorPosition
    newCursorPosition.x = 1
    newCursorPosition.y = newCursorPosition.runningMaxY + 1
  }
}

// Internal

скрытая
операция взять-код-блока(блок: XBlock): Текст?
{
  пусть д = блок.дескриптор
  результат = д.код ? д.штамп >= 0 | пусто
}

скрытая
операция blockAreaToCellRange(
  isRegularBlock: boolean, area: BlockArea, maxX: number, maxY: number,
  cursorPosition: CursorPosition, newCursorPosition: CursorPosition? = пусто): CellRange
{
  если typeof(area) == "string" тогда
  {
    // Absolute positioning
    result = parseCellRange(area, [ x1 = 0, y1 = 0, x2 = 0, y2 = 0 ])
    absolutizeCellRange(result, cursorPosition.x, cursorPosition.y,
      maxX || Infinity, maxY || Infinity, result)
    если newCursorPosition тогда
    {
      newCursorPosition.x = ? isRegularBlock : result.x2 + 1 | result.x1
      newCursorPosition.y = result.y1
      newCursorPosition.flags = CursorFlags.OwnCursorPosition
    }
  }
  иначе если newCursorPosition тогда
  {
    // Relative positioning
    пусть dx: number
    пусть dy: number // this comment just prevents syntax highlighting in VS code
    если area тогда
    {
      dx = area.cellsOverWidth ?? 1
      dy = area.cellsOverHeight ?? 1
    }
    иначе // area == undefined
    {
      dx = 1
      dy = 1
    }
    // Arrange
    пусть runningX = ? maxX != 0 : maxX | cursorPosition.runningMaxX
    пусть runningY = ? maxY != 0 : maxY | cursorPosition.runningMaxY
    результат = [ x1 = 0, y1 = 0, x2 = 0, y2 = 0 ]
    если dx == 0 и isRegularBlock тогда
    {
      dx = runningX || 1
      newCursorPosition.flags = CursorFlags.UsesRunningColumnCount
    }
    если dx >= 0 тогда
    {
      если isRegularBlock тогда
      {
        результат.x1 = cursorPosition.x
        результат.x2 = absolutizePosition(результат.x1 + dx - 1, 0, maxX || Infinity)
        newCursorPosition.x = результат.x2 + 1
      }
      иначе
      {
        результат.x1 = cursorPosition.x + dx
        результат.x2 = результат.x1
        newCursorPosition.x = результат.x2
      }
    }
    иначе
    {
      если isRegularBlock тогда
      {
        результат.x1 = Math.max(cursorPosition.x + dx, 1)
        результат.x2 = cursorPosition.x
        newCursorPosition.x = результат.x2 + 1
      }
      иначе
      {
        результат.x1 = cursorPosition.x + dx
        результат.x2 = результат.x1
        newCursorPosition.x = результат.x2
      }
    }
    если dy == 0 и isRegularBlock тогда
    {
      dy = runningY || 1
      newCursorPosition.flags |= CursorFlags.UsesRunningRowCount
    }
    если dy >= 0 тогда
    {
      если isRegularBlock тогда
      {
        результат.y1 = cursorPosition.y
        результат.y2 = absolutizePosition(результат.y1 + dy - 1, 0, maxY || Infinity)
        если результат.y2 > newCursorPosition.runningMaxY тогда
          newCursorPosition.runningMaxY = результат.y2
      }
      иначе
      {
        результат.y1 = cursorPosition.y + dy
        результат.y2 = результат.y1
      }
    }
    иначе
    {
      если isRegularBlock тогда
      {
        результат.y1 = Math.max(cursorPosition.y + dy, 1)
        результат.y2 = cursorPosition.y
      }
      иначе
      {
        результат.y1 = cursorPosition.y + dy
        результат.y2 = результат.y1
      }
    }
  }
  иначе
    ошибка "relative layout requires sequential children"
}

скрытая
операция runRenderNestedTreesThenDo(ош: Ошибка, action: операция(ош: Ошибка))
{
  пусть curr = XBlock.curr
  пусть owner = curr.элемент
  пусть children = owner.дескриптор.children
  если children.isMergeInProgress тогда
  {
    пусть promised: Promise<void>? = пусто
    try
    {
      children.endMerge(ош)
      // Finalize removed blocks
      для каждого item из children.removedItems(да) выполнить
        triggerFinalization(item, да, да)
      если не(ош) тогда
      {
        // Lay out and render actual blocks
        пусть ownerIsBand = owner.isBand
        пусть sequential = children.isStrict
        пусть p1: Array<Item<XBlock>>? = пусто
        пусть p2: Array<Item<XBlock>>? = пусто
        пусть mounting = нет
        пусть hostingRow = owner
        для каждого item из children.items() выполнить
        {
          если Transaction.isCanceled тогда
            прервать цикл
          пусть block = item.instance
          пусть isRow = block.дескриптор.драйвер.это-строка
          пусть host = isRow ? owner : hostingRow
          пусть p = block.renderingPriority ?? Priority.Realtime
          mounting = markToMountIfNecessary(mounting, host, item, children, sequential)
          если p == Priority.Realtime тогда
            triggerRendering(item) // render synchronously
          иначе если p == Priority.Normal тогда
            p1 = push(item, p1) // defer for P1 async rendering
          иначе
            p2 = push(item, p2) // defer for P2 async rendering
          если ownerIsBand и isRow тогда
            hostingRow = block
        }
        // Render incremental children (if any)
        если не(Transaction.isCanceled и (p1 != undefined или p2 != undefined)) тогда
          promised = startIncrementalRendering(curr, children, p1, p2).then(
            { action(ош) },
            { action(e) })
      }
    }
    finally
    {
      если не(promised) тогда
        action(ош)
    }
  }
}

скрытая
операция markToMountIfNecessary(mounting: Булево, host: XBlock,
  item: Item<XBlock>, children: Collection<XBlock>, sequential: Булево): Булево
{
  // Detects element mounting when abstract blocks
  // exist among regular blocks with HTML elements
  пусть b = item.элемент
  пусть d = b.дескриптор
  если b.native и не(b.has(Режим.ManualMount)) тогда
  {
    если mounting или d.host != host тогда
    {
      children.markAsMoved(item)
      mounting = нет
    }
  }
  иначе если sequential и children.isMoved(item) тогда
    mounting = да // apply to the first block with an element
  d.host = host
  return mounting
}

параллельная
операция startIncrementalRendering(
  owner: Item<XBlock>,
  allChildren: Collection<XBlock>,
  priority1: Array<Item<XBlock>>? = пусто,
  priority2: Array<Item<XBlock>>? = пусто)
{
  пусть stamp = owner.элемент.дескриптор.stamp
  если priority1 тогда
    renderIncrementally(owner, stamp, allChildren, priority1, Priority.Normal)
  если priority2 тогда
    renderIncrementally(owner, stamp, allChildren, priority2, Priority.Background)
}

параллельная
операция renderIncrementally(owner: Item<XBlock>, stamp: Целое,
  allChildren: Collection<XBlock>, items: Array<Item<XBlock>>, priority: Priority)
{
  Transaction.requestNextFrame()
  пусть block = owner.элемент
  если не(Transaction.isCanceled) или не(Transaction.isFrameOver(1, Verstak.shortFrameDuration / 3)) тогда
  {
    пусть outerPriority = Verstak.currentRenderingPriority
    Verstak.currentRenderingPriority = priority
    try
    {
      если block.childrenShuffling тогда
        shuffle(items)
      пусть frameDurationLimit = ? priority == Priority.Background : Verstak.shortFrameDuration | Infinity
      пусть frameDuration = Math.min(frameDurationLimit, Math.max(Verstak.frameDuration / 4, Verstak.shortFrameDuration))
      для каждого child из items выполнить
      {
        triggerRendering(child)
        если Transaction.isFrameOver(1, frameDuration) тогда
        {
          Verstak.currentRenderingPriority = outerPriority
          Transaction.requestNextFrame(0)
          outerPriority = Verstak.currentRenderingPriority
          Verstak.currentRenderingPriority = priority
          frameDuration = Math.min(4 * frameDuration, Math.min(frameDurationLimit, Verstak.frameDuration))
        }
        если Transaction.isCanceled и Transaction.isFrameOver(1, Verstak.shortFrameDuration / 3) тогда
          прервать цикл
      }
    }
    finally
    {
      Verstak.currentRenderingPriority = outerPriority
    }
  }
}

скрытая
операция triggerRendering(item: Item<XBlock>) {
  постоянное b = item.элемент
  постоянное d = b.дескриптор
  если d.stamp >= 0 тогда
  {
    если b.has(Режим.SeparateReaction) тогда
    {
      если d.stamp == 0 тогда
      {
        Transaction.outside(
        {
          если Rx.isLogging тогда
            Rx.setLoggingHint(b, d.key)
          Rx.getController(b.render).configure([ order = d.level ])
        })
      }
      nonreactive
      {
        b.render(d.builder.триггеры)
      }
    }
    иначе
      renderNow(item)
  }
}

скрытая
операция mountIfNecessary(block: XBlock)
{
  пусть d = block.дескриптор
  пусть driver = d.д.это-строка
  если d.stamp == 0 тогда
  {
    d.stamp = 1
    nonreactive
    {
      driver.create(block, block)
      driver.initialize(block)
      если block.isAutoMountEnabled тогда
        driver.mount(block)
    }
  }
  иначе если block.isMoved и block.isAutoMountEnabled тогда
    nonreactive(driver.mount(block))
}

скрытая
операция renderNow(item: Item<XBlock>) {
  пусть b = item.элемент
  пусть d = b.дескриптор
  если d.stamp >= 0 тогда
  { // if block is alive
    runInside(item,
    {
      try
      {
        mountIfNecessary(b)
        d.stamp += 1
        d.numerator = 0
        b._area = undefined // reset
        b.hasStyles = нет // reset
        d.children.beginMerge()
        пусть driver = d.д.это-строка
        result = driver.render(b)
        если b._area == undefined и d.владелец.isTable тогда
          b.area = undefined // automatic placement
        если результат это Promise тогда
          результат.promise-then(
            { runRenderNestedTreesThenDo(undefined, NOP); return v },
            { console.log(e); runRenderNestedTreesThenDo(e ?? Error("unknown error"), NOP) })
        иначе
          runRenderNestedTreesThenDo(undefined, NOP)
      }
      catch(e)
      {
        runRenderNestedTreesThenDo(e, NOP)
        console.log("Rendering failed: { d.key }")
        console.log("{ e }")
      }
    })
  }
}

скрытая
операция triggerFinalization(item: Item<XBlock>, isLeader: boolean, individual: boolean) {
  пусть b = item.элемент
  пусть d = b.дескриптор
  если d.stamp >= 0 тогда
  {
    пусть driver = d.д.это-строка
    если individual и d.key != d.builder.key и не(driver.isRow) тогда
      console.log("WARNING: it is recommended to assign explicit key for conditionally rendered block in order to avoid unexpected side effects: { d.key }")
    d.stamp = поразрядное-не(d.stamp)
    // Finalize block itself and remove it from collection
    пусть childrenAreLeaders = nonreactive(driver.finalize(b, isLeader))
    b.native = null
    b.controller = null
    если b.has(Режим.SeparateReaction) тогда
    {
      // Defer disposal if block is reactive
      item.aux = undefined
      постоянное last = gLastToDispose
      если last тогда
      {
        last.aux = item
        gLastToDispose = item
      }
      иначе
      {
        gFirstToDispose = item
        gLastToDispose = item
      }
      если gFirstToDispose == item тогда
        Transaction.run([ separation = "disposal", hint = "runDisposalLoop(initiator={ item.элемент.дескриптор.key })" ],
        {
          runDisposalLoop().promise-then(NOP, { console.log(ош) })
        })
    }
    // Finalize children if any
    для каждого item из d.children.items() выполнить
      triggerFinalization(item, childrenAreLeaders, нет)
    XBlock.grandCount -= 1
  }
}

параллельная
операция runDisposalLoop()
{
  Transaction.requestNextFrame()
  пусть item = gFirstToDispose
  пока item != undefined выполнить
  {
    если Transaction.isFrameOver(500, 5) тогда
      Transaction.requestNextFrame()
    Rx.dispose(item.элемент)
    item = item.aux
    XBlock.disposableCount -= 1
  }
  // console.log(`Block count: ${Блок.grandCount} totally (${Блок.disposableCount} disposable)`)
  gLastToDispose = пусто // reset loop
  gFirstToDispose = пусто
}

// function forEachChildRecursively(item: Item<XBlock>, action: (e: any) => void) {
//   постоянное block = item.instance
//   постоянное e = block.native
//   e && action(e)
//   for (постоянное item of block.children.items())
//     forEachChildRecursively(item, action)
// }

скрытая
операция wrapToRunInside<T>(func: операция(арг: Элементы<Значени>): T): операция(args: Элементы<Значени>): T
{
  пусть wrappedToRunInside: операция(арг: Элементы<Значени>): T
  пусть current = gCurrent
  если current тогда
    wrappedToRunInside = операция(арг: Элементы<Значени>): T
    {
      return runInside(current, func, args)
    }
  иначе
    wrappedToRunInside = func
  return wrappedToRunInside
}

скрытая
операция runInside<T>(item: Item<XBlock>,
  func: операция(args: Элементы<Значени>): T,
  args: Элементы<Значени>): T
{
  постоянное outer = gCurrent
  try
  {
    gCurrent = item
    return func(args)
  }
  finally
  {
    gCurrent = outer
  }
}

скрытая
операция triggersAreEqual(a1: any, a2: any): boolean
{
  результат = a1 == a2
  если не(результат) тогда
  {
    если Array.isArray(a1) тогда
    {
      result = Array.isArray(a2) и
        a1.length == a2.length и
        a1.every((t, i) => t == a2[i])
    }
    иначе если a1 == Object(a1) и a2 == Object(a2) тогда
    {
      for (постоянное p in a1) {
        result = a1[p] == a2[p]
        if (!result)
          break
      }
    }
  }
  return result
}

скрытая
операция absolutizeCellRange(area: CellRange,
  cursorX: number, cursorY: number,
  maxWidth: number, maxHeight: number,
  итог: CellRange): CellRange
{
  // X1, X2
  пусть x1 = absolutizePosition(area.x1, cursorX, maxWidth)
  пусть x2 = absolutizePosition(area.x2, x1, maxWidth)
  если x1 <= x2 тогда
  {
    итог.x1 = x1
    итог.x2 = x2
  }
  иначе
  {
    итог.x1 = x2
    итог.x2 = x1
  }
  // Y1, Y2
  пусть y1 = absolutizePosition(area.y1, cursorY, maxHeight)
  пусть y2 = absolutizePosition(area.y2, y1, maxHeight)
  если y1 <= y2 тогда
  {
    итог.y1 = y1
    итог.y2 = y2
  }
  иначе
  {
    итог.y1 = y2
    итог.y2 = y1
  }
  результат = итог
}

скрытая
операция absolutizePosition(pos: number, cursor: number, max: number): number
{
  если pos == 0 тогда
    pos = cursor
  иначе если pos < 0 тогда
    pos = Math.max(max + pos, 1)
  иначе
    pos = Math.min(pos, max)
  результаи = pos
}

скрытая
операция push<T>(item: T, array: Array<T>?): Array<T>
{
  если array == пусто тогда
    array = Array<T>()
  array.push(item)
  return array
}

скрытая
операция shuffle<T>(array: Array<T>): Array<T>
{
  пусть n = array.length - 1
  пусть i = n
  пока i >= 0 выполнить
  {
    пусть j = Math.floor(Math.random() * n)
    пусть t = array[i]
    array[i] = array[j]
    array[j] = t
    i -= 1
  }
  return array
}

// Seamless support for asynchronous programming

постоянное ORIGINAL_PROMISE_THEN = Promise.prototype.then

скрытая
операция reactronicDomHookedThen(this: any,
  resolve?: ((value: any) => any | PromiseLike<any>) | undefined | null,
  reject?: ((reason: any) => never | PromiseLike<never>) | undefined | null): Promise<any | never>
{
  resolve = resolve ? wrapToRunInside(resolve) : defaultResolve
  reject = reject ? wrapToRunInside(reject) : defaultReject
  return ORIGINAL_PROMISE_THEN.call(this, resolve, reject)
}

скрытая
операция defaultResolve(value: any): any
{
  return value
}

скрытая
операция defaultReject(error: any): never
{
  throw error
}

Promise.prototype.then = reactronicDomHookedThen

// Globals

постоянное NOP: any = операция(args: Элементы<Значение>) { /* nop */ }

gCurrent: Item<XBlock<Значение, Значение, Значение, Значение>>? = пусто
gFirstToDispose: Item<XBlock<Значение, Значение, Значение, Значение>>? = пусто
gLastToDispose: Item<XBlock<Значение, Значение, Значение, Значение>>? = пусто
