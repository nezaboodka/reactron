// The below copyright notice and the license permission notice
// shall be included in all copies or substantial portions.
// Copyright (C) 2019-2022 Nezaboodka Software <contact@nezaboodka.com>
// License: https://raw.githubusercontent.com/nezaboodka/verstak/master/LICENSE
// By contributing, you agree that your contributions will be
// automatically licensed under the license referred above.

// import { reactive, nonreactive, Transaction, options, Reentrance, Rx, LoggingOptions, Collection, Item, ObservableObject, raw, MemberOptions } from "reactronic"
// import { Рамка, Layout, Priority, Режим, Align, BlockArea, КонструкторБлока, Блок, Driver, ПростойДелегат, БлокDescriptor, БлокCtx } from "./Interfaces"
// import { emitLetters, equalCellRanges, parseCellRange, getCallerInfo } from "./Utils"

используется артель

// Verstak

тип Verstak = ссылка на объект
{
  общее постоянное shortFrameDuration = 16 // ms
  общее постоянное longFrameDuration = 300 // ms
  общее currentRenderingPriority = Приоритет.высокий
  общее frameDuration = Verstak.longFrameDuration

  общая
  операция заявить<T = Ничего, M = Значение, C = Значение, R = Ничего>(
    драйвер: Драйвер<T, C>, конструктор: КонструкторБлока<T, M, C, R>?,
    оригинал: КонструкторБлока<T, M, C, R>?): Блок<T, M, C, R>
  {
    // Нормализация аргументов
    если конструктор != пусто тогда
      конструктор.оригинал = оригинал
    else
      конструктор = оригинал ?? []
    пусть код = конструктор.код
    пусть владелец = gCurrent?.элемент
    если владелец != пусто тогда
    {
      // Check for coalescing separators or lookup for existing block
      пусть пре: Item<XBlock<Значение, Значение, Значение, Значение>>? = пусто
      пусть дети = владелец.дескриптор.дети
      если драйвер.это-строка тогда
      {
        пусть последний = дети.lastClaimedItem()
        если последний?.элемент?.дескриптор.драйвер == драйвер тогда
          пре = последний
      }
      // ex ??= дети.claim(
      //   key = код || generateKey(владелец), undefined,
      //   "nested blocks can be declared inside render function only")
      если пре == пусто тогда
      {
        если код == пусто или код == "" тогда
          код = сгенерировать-код(владелец!)
        пре = дети.claim(код, пусто, "nested blocks can be declared inside render function only")
      }
      // Reuse existing block or claim a new one
      если пре != пусто тогда
      {
        // Reuse existing block
        результат = пре.элемент как XBlock<T, M, C, R>
        пусть д = результат.дескриптор
        если д.драйвер != драйвер и драйвер != пусто тогда
          ошибка "changing block драйвер is not yet supported: \"{ результат.дескриптор.драйвер.name }\" -> \"{ драйвер?.name }\""
        пусть преТриггеры = д.конструктор.триггеры
        если triggersAreEqual(конструктор.триггеры, преТриггеры) тогда
          конструктор.триггеры = преТриггеры // preserve триггеры instance
        д.конструктор = конструктор!
      }
      иначе
      {
        // Create new block
        результат = XBlock<T, M, C, R>(
          код ? (код != пусто и код != "") | сгенерировать-код(владелец),
          драйвер, владелец, конструктор!)
        результат.дескриптор.экземпляр = дети.добавить(результат)
      }
    }
    иначе
    {
      // Create new root block
      результат = XBlock<T, M, C, R>(код ?? "", драйвер, владелец, конструктор!)
      результат.дескриптор.экземпляр = Collection.createItem(результат)
      triggerRendering(результат.дескриптор.экземпляр)
    }
  }

  // static get block(): Блок {
  //   if (gCurrent == undefined)
  //     throw new Error("current block is undefined")
  //   return gCurrent.instance
  // }

  общая
  операция renderNestedTreesThenDo(action: операция(о: Ошибка))
  {
    runRenderNestedTreesThenDo(пусто, action)
  }

  общая
  операция getDefaultLoggingOptions(): LoggingOptions?
  {
    return XBlock.logging
  }

  общая
  операция setDefaultLoggingOptions(logging: LoggingOptions?)
  {
    XBlock.logging = logging
  }
}

// БазовыйДрайвер

тип БазовыйДрайвер<T, C = Значение> = ссылка на объект
на основе Драйвер<T, C>
{
  общее постоянное фрагмент = БазовыйДрайвер<Значение, Значение>(
    "фрагмент", нет, { блок.раскладка-детей = Раскладка.группа })

  имя: Текст
  это-строка: Булево
  преднастройка: ПростойДелегат<T>?

  при создании(
    имя`: Текст,
    это-строка`: Булево,
    преднастройка`: ПростойДелегат<T>?)
  {
    имя = имя`
    это-строка = это-строка`
    преднастройка = преднастройка`
  }

  операция заявить(блок: Блок<T, Значение, C, Ничего>)
  {
    пусть б = блок как XBlock<T, Значение, C, Ничего>
    chainedClaim(б, б.дескриптор.конструктор)
  }

  подмена
  операция create(block: Блок<T, Значение, C, Ничего>, b: объект { native: T?; controller: C? })
  {
    chainedCreate(block, block.дескриптор.конструктор)
  }

  подмена
  операция initialize(block: Блок<T, Значение, C, Ничего>)
  {
    пусть б = block как XBlock<T, Значение, C, Ничего>
    если преднастройка != пусто тогда
      преднастройка(б)
    chainedInitialize(б, б.дескриптор.конструктор)
  }

  подмена
  операция mount(block: Блок<T, Значение, C, Ничего>)
  {
    // nothing to do by default
  }

  подмена
  операция render(block: Блок<T, Значение, C, Ничего>)
  {
    chainedRender(block, block.дескриптор.конструктор)
  }

  подмена
  операция finalize(block: Блок<T, Значение, C, Ничего>, isLeader: Булево): Булево
  {
    пусть б = block как XBlock<T, Значение, C, Ничего>
    chainedFinalize(б, б.дескриптор.конструктор)
    return isLeader // treat children as finalization leaders as well
  }

  подмена
  операция applyChildrenLayout(block: Блок<T, Значение, C, Значение>, value: Layout)
  {
    // do nothing
  }

  подмена
  операция applyCellRange(block: Блок<T, Значение, C, Значение>, value: Рамка?)
  {
    // do nothing
  }

  подмена
  операция applyWidthGrowth(block: Блок<T, Значение, C, Значение>, value: Число)
  {
    // do nothing
  }

  подмена
  операция applyMinWidth(block: Блок<T, Значение, C, Значение>, value: Текст)
  {
    // do nothing
  }

  подмена
  операция applyMaxWidth(block: Блок<T, Значение, C, Значение>, value: Текст)
  {
    // do nothing
  }

  подмена
  операция applyHeightGrowth(block: Блок<T, Значение, C, Значение>, value: Число)
  {
    // do nothing
  }

  подмена
  операция applyMinHeight(block: Блок<T, Значение, C, Значение>, value: Текст)
  {
    // do nothing
  }

  подмена
  операция applyMaxHeight(block: Блок<T, Значение, C, Значение>, value: Текст)
  {
    // do nothing
  }

  подмена
  операция applyContentAlignment(block: Блок<T, Значение, C, Значение>, value: Align)
  {
    // do nothing
  }

  подмена
  операция applyBlockAlignment(block: Блок<T, Значение, C, Значение>, value: Align)
  {
    // do nothing
  }

  подмена
  операция applyContentWrapping(block: Блок<T, Значение, C, Значение>, value: Булево)
  {
    // do nothing
  }

  подмена
  операция applyOverlayVisible(block: Блок<T, Значение, C, Значение>, value: Булево?)
  {
    // do nothing
  }

  подмена
  операция applyStyle(block: Блок<T, Значение, C, Значение>, secondary: Булево, styleName: string, enabled: Булево?)
  {
    // do nothing
  }
}

// Utils

скрытая
операция сгенерировать-код(владелец: XBlock<Значение, Значение, Значение, Значение>): Текст
{
  владелец.дескриптор.номер += 1
  пусть номер = владелец.дескриптор.номер
  пусть буквы = emitLetters(номер)
  если Rx.isLogging тогда
    result = "·{ getCallerInfo(буквы) }"
  иначе
    result = "·{ буквы }"
}

скрытая
операция chainedMode(конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>?): Режим
{
  return конструктор?.режим ?? (? конструктор?.оригинал : chainedMode(конструктор?.оригинал) | Режим.обычный)
}

скрытая
операция chainedClaim(блок: Блок<Значение, Значение, Значение, Значение>,
  конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>)
{
  пусть заявить = конструктор.заявить
  пусть оригинал = конструктор.оригинал
  если заявить != пусто тогда
    заявить(блок, ? оригинал : { chainedClaim(блок, оригинал) } | NOP)
  иначе если оригинал != пусто тогда
    chainedClaim(блок, оригинал)
}

скрытая
операция chainedCreate(блок: Блок<Значение, Значение, Значение, Значение>,
  конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>)
{
  пусть создать = конструктор.создать
  пусть оригинал = конструктор.оригинал
  если создать != пусто тогда
    создать(блок, ? оригинал : { chainedCreate(блок, оригинал) } | NOP)
  иначе если оригинал != пусто тогда
    chainedCreate(блок, оригинал)
}

скрытая
операция chainedInitialize(блок: Блок<Значение, Значение, Значение, Значение>,
  конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>)
{
  пусть подготовить = конструктор.подготовить
  пусть оригинал = конструктор.оригинал
  если подготовить != пусто тогда
    подготовить(блок, ? оригинал : { chainedInitialize(блок, оригинал) } | NOP)
  иначе если оригинал != пусто тогда
    chainedInitialize(блок, оригинал)
}

скрытая
операция chainedRender(блок: Блок<Значение, Значение, Значение, Значение>,
  конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>)
{
  пусть показать = конструктор.показать
  пусть оригинал = конструктор.оригинал
  если показать != пусто тогда
    показать(блок, ? оригинал : { chainedRender(блок, оригинал) } | NOP)
  иначе если оригинал != пусто тогда
    chainedRender(блок, оригинал)
}

скрытая
операция chainedFinalize(блок: Блок<Значение, Значение, Значение, Значение>,
  конструктор: КонструкторБлока<Значение, Значение, Значение, Значение>)
{
  пусть завершить = конструктор.завершить
  пусть оригинал = конструктор.оригинал
  если завершить != пусто тогда
    завершить(блок, ? оригинал : { chainedFinalize(блок, оригинал) } | NOP)
  иначе если оригинал != пусто тогда
    chainedFinalize(блок, оригинал)
}

тип StaticDriver<T> = ссылка на объект
на основе БазовыйДрайвер<T, Ничего>
{
  постоянный элемент: T

  при создании(элемент`: T, имя: Текст,
    это-строка: Булево, преднастройка: ПростойДелегат<T>?)
  {
    основа(имя, это-строка, преднастройка)
    элемент = элемент`
  }

  подмена
  операция создать(block: Блок<T, Значение, Значение, Ничего>,
    b: объект { native: T?; controller: Значение? })
  {
    b.native = элемент
  }
}

// CursorCommandDriver

тип CursorCommand = ссылка на объект
{
  absolute: Текст?
  columnShift: Целое?
  rowShift: Целое?
}

тип CursorCommandDriver = ссылка на объект
на основе БазовыйДрайвер<CursorCommand, Ничего>
{
  при создании()
  {
    основа("курсор", нет, { блок.раскладка-детей = Раскладка.курсор })
  }

  подмена
  операция создать(блок: Блок<CursorCommand, Значение, Ничего, Ничего>,
    б: объект { native: CursorCommand?; controller: Значение? })
  {
    б.native = CursorCommand()
    основа(блок, б)
  }
}

// ContextVariable

тип ContextVariable<T: Объект = Объект> = ссылка на объект
{
  постоянное defaultValue: T?

  при создании(defaultValue`: T?)
  {
    defaultValue = defaultValue`
  }

  // set value(value: T)
  // {
  //   XBlock.setContextVariableValue(объект, значение)
  // }

  // get value(): T
  // {
  //   return XBlock.useContextVariableValue(this)
  // }

  // get valueOrUndefined(): T | undefined
  // {
  //   return XBlock.tryUseContextVariable(this)
  // }
}

// XBlock

тип CursorPosition = ссылка на объект
{
  x: Целое
  y: Целое
  runningMaxX: Целое
  runningMaxY: Целое
  flags: CursorFlags

  при создании(пре: CursorPosition) {
    x = пре.x
    y = пре.y
    runningMaxX = пре.runningMaxX
    runningMaxY = пре.runningMaxY
    flags = поразрядное-и(пре.flags, поразрядное-не(CursorFlags.OwnCursorPosition))
  }
}

тип CursorFlags = вариант
{
  не-задано = 0
  независимость-от-курсора = 1
  зависимость-от-нарастающей-ширины = 2
  зависимость-от-нарастающей-высоты = 4
}

постоянное UndefinedCellRange = Объект.freeze([ x1 = 0, y1 = 0, x2 = 0, y2 = 0 ])
постоянное InitialCursorPosition: CursorPosition = Объект.freeze(CursorPosition([ x = 1, y = 1, runningMaxX = 0, runningMaxY = 0, flags = CursorFlags.None ]))

тип XBlockCtx<T: Объект = Объект> = ссылка на объект
на основе ObservableObject, БлокCtx<T>
{
  #raw next: XBlockCtx<Объект>?
  #raw variable: ContextVariable<T>
  value: T

  при создании(variable: ContextVariable<T>, value: T) {
    основа()
    next = пусто
    variable = variable
    value = value
  }
}

тип XBlockDescriptor<T = Значение, M = Значение, C = Значение, R = Ничего> = ссылка на объект
на основе ДескрипторБлока<T, M, C, R>
{
  постоянный код: Текст
  постоянный драйвер: Драйвер<T, C>
  конструктор: КонструкторБлока<T, M, C, R>
  постоянный уровень: Целое
  постоянный владелец: XBlock<Значение, Значение, Значение, Значение>
  хостер: XBlock<Значение, Значение, Значение, Значение>
  постоянное дети: Collection<XBlock<Значение, Значение, Значение, Значение>>
  item: Item<XBlock<Значение, Значение, Значение, Значение>>?
  штапм: Целое
  outer: XBlock<Значение, Значение, Значение, Значение>
  контекст: XBlockCtx<Значение>?
  номер: Целое
  maxColumnCount: Целое = 0
  maxRowCount: Целое = 0
  cursorPosition: CursorPosition?

  при создании(код`: Текст, драйвер`: Драйвер<T, C>,
    конструктор`: Readonly<КонструкторБлока<T, M, C, R>>,
    блок: XBlock<T, M, C, R>, владелец`: XBlock<Значение, Значение, Значение, Значение>?)
  {
    код = код`
    драйвер = драйвер`
    конструктор = конструктор`
    если владелец` тогда
    {
      пусть д = владелец`.дескриптор
      уровень = д.уровень + 1
      владелец = владелец`
      outer = владелец` ? д.контекст | д.outer
    }
    иначе
    {
      уровень = 1
      владелец` = блок
      владелец = блок
      outer = блок
    }
    хостер = блок // block is unmounted
    дети = Collection<XBlock<Значение, Значение, Значение, Значение>>(взять-код-блока, да)
    item = пусто
    штамп = 0
    контекст = пусто
    номер = 0
    maxColumnCount = 0
    maxRowCount = 0
    cursorPosition = пусто
  }
}

тип XBlock<T = Значение, M = Значение, C = Значение, R = Значение> = ссылка на объект
на основе Блок<T, M, C, R>
{
  // Static properties
  общее grandCount: Целое = 0
  общее disposableCount: Целое = 0
  общее logging: НастройкиЖурнализации? = пусто

  // System-managed properties
  охраняемое типом дескриптор: XBlockDescriptor<T, M, C, R>
  реализация: T

  // User-defined properties
  модель: M
  контролер: C
  // _childrenLayout: Раскладка
  // _area: ОбластьБлока
  // скрытое _cellRange: Рамка
  // скрытое _widthGrowth: Число
  // скрытое _minWidth: Текст
  // скрытое _maxWidth: Текст
  // скрытое _heightGrowth: Число
  // скрытое _minHeight: Текст
  // скрытое _maxHeight: Текст
  // скрытое _contentAlignment: Align
  // скрытое _blockAlignment: Align
  // скрытое _contentWrapping: Булево
  // скрытое _overlayVisible: Булево?
  hasStyles: Булево
  childrenShuffling: Булево
  renderingPriority: Приоритет

  при создании(код`: Текст, драйвер`: Драйвер<T, C>,
    владелец`: XBlock<Значение, Значение, Значение, Значение>?,
    конструктор: КонструкторБлока<T, M, C, R>)
  {
    // System-managed properties
    дескриптор = XBlockDescriptor(код`, драйвер`, конструктор, объект, владелец`)
    реализация = пусто как Значение как T // hack
    // User-defined properties
    модель = пусто как Значение
    контролер = пусто как Значение как C // hack
    // _childrenLayout = Layout.Row
    // _area = undefined
    // _cellRange = UndefinedCellRange
    // _widthGrowth = 0
    // _minWidth = ""
    // _maxWidth = ""
    // _heightGrowth = 0
    // _minHeight = ""
    // _maxHeight = ""
    // _contentAlignment = Align.Default
    // _blockAlignment = Align.Default
    // _contentWrapping = нет
    // _overlayVisible = undefined
    hasStyles = нет
    childrenShuffling = нет
    renderingPriority = Приоритет.высокий
    // Monitoring
    XBlock.grandCount += 1
    если включен-режим(Режим.раздельная-реакция) тогда
      XBlock.disposableCount += 1
  }

  // @reactive
  // @options({
  //   reentrance: Reentrance.CancelPrevious,
  //   triggeringArgs: да,
  //   noSideEffects: нет,
  // })
  реактивная
  операция render(триггеры: Значение) {
    // триггеры parameter is used to enforce rendering by owner
    renderNow(дескриптор.экземпляр!)
  }

  операция включен-режим(режим: Режим): Булево
  {
    результат = поразрядное-и(chainedMode(дескриптор.конструктор), режим) == режим
  }

  охраняемое типом
  isInitialRendering: Булево
    при чтении { результат = дескриптор.штамп == 2 }

  isSequential: Булево
    при чтении { результат = дескриптор.дети.isStrict }
    при записи { дескриптор.дети.isStrict = значение }

  охраняемое типом
  isAuxiliary: Булево
    при чтении { результат = раскладка-детей > Раскладка.заметка } // Row, Group, Cursor

  охраняемое типом
  isBand: Булево
    при чтении { результат = раскладка-детей == Раскладка.лента }

  охраняемое типом
  isTable: Булево
    при чтении { результат = раскладка-детей == Раскладка.таблица }

  охраняемое типом
  isAutoMountEnabled: Булево
    при чтении { return не(включен-режим(Режим.ручное-встраивание)) и дескриптор.хостер != объект }

  охраняемое типом
  isMoved: Булево
    при чтении { return дескриптор.владелец.дескриптор.дети.isMoved(дескриптор.экземпляр!) }

  раскладка-детей: Раскладка
    при записи
    {
      если значение != хранимое или дескриптор.штапм < 2 тогда
      {
        дескриптор.драйвер.применить-раскладку-детей(объект, значение)
        хранимое = значение
      }
    }

  area: ОбластьБлока
    при записи
    {
      пусть д = дескриптор
      пусть драйвер = д.драйвер
      если не(драйвер.это-строка) тогда
      {
        пусть вд = д.владелец.дескриптор
        пусть cursorPosition = д.экземпляр!.prev?.instance.дескриптор.cursorPosition ?? InitialCursorPosition
        пусть newCursorPosition = ? owner.children.isStrict : CursorPosition(cursorPosition) | пусто
        пусть isCursorBlock = драйвер это CursorCommandDriver
        пусть cellRange = blockAreaToCellRange(не(isCursorBlock),
          значение, вд.maxColumnCount, вд.maxRowCount,
          cursorPosition, newCursorPosition)
        д.cursorPosition = newCursorPosition
        если не(equalCellRanges(cellRange, this._cellRange)) тогда
        {
          драйвер.applyCellRange(объект, cellRange)
          this._cellRange = cellRange
        }
        хранимое = значение ?? { }
      }
      иначе
        rowBreak()
    }

  widthGrowth: Число
    при записи {
      если параметр != хранимое тогда
      {
        дескриптор.драйвер.применить-долю-роста-ширины(объект, параметр)
        хранимое = параметр
      }
    }

  minWidth: Текст
    при записи
    {
      если параметр != хранимое тогда
      {
        дескриптор.драйвер.применить-минимальную-ширину(объект, параметр)
        хранимое = параметр
      }
    }

  maxWidth: Текст
   при записи
   {
      если параметр != хранимое тогда
      {
        дескриптор.драйвер.применить-максимальную-ширину(объект, параметр)
        хранимое = параметр
      }
    }

  heightGrowth: Число
    при записи
    {
      если параметр != хранимое тогда
      {
        дескриптор.драйвер.применить-долю-роста-высоты(объект, параметр)
        хранимое = параметр
      }
    }

  minHeight: Текст
    при записи
    {
      если параметр != хранимое тогда
      {
        дескриптор.драйвер.применить-минимальную-высоту(объект, параметр)
        хранимое = параметр
      }
    }

  maxHeight: Текст
    при записи
    {
      если параметр != хранимое тогда
      {
        дескриптор.драйвер.применить-максимальную-высоту(объект, параметр)
        хранимое = параметр
      }
   }

  contentAlignment: Выравнивание
    при записи
    {
      если параметр != хранимое тогда
      {
        дескриптор.драйвер.применить-выравнивание-содержимого(объект, параметр)
        хранимое = параметр
      }
    }

  blockAlignment: Выравнивание
    при записи
    {
      если параметр != хранимое тогда
      {
        дескриптор.драйвер.применить-выравнивание-блока(объект, параметр)
        хранимое = параметр
      }
    }

  contentWrapping: Булево
    при записи
    {
      если параметр != хранимое тогда
      {
        дескриптор.драйвер.применить-перенос-содержимого(объект, параметр)
        хранимое = параметр
      }
    }

  overlayVisible: Булево?
    при записи
    {
      если параметр != хранимое тогда
      {
        дескриптор.драйвер.applyOverlayVisible(объект, параметр)
        хранимое = параметр
      }
    }

  операция style(styleName: Текст, вкл: Булево?)
  {
    дескриптор.драйвер.применить-стиль(объект, hasStyles, styleName, вкл)
    hasStyles = да
  }

  операция configureReactronic(options: Partial<MemberOptions>): MemberOptions
  {
    если дескриптор.штамп != 1 или не(включен-режим(Режим.раздельная-реакция)) тогда
      ошибка "reactronic can be configured only for blocks with separate reaction mode and only inside initialize"
    return Rx.getController(this.render).configure(options)
  }

  общее
  охраняемое типом
  curr: Item<XBlock<Значение, Значение, Значение, Значение>>
    при записи
    {
      если gCurrent == пусто тогда
        ошибка "current block is undefined"
      результат = gCurrent
    }

  общая
  операция tryUseContextVariable<T: Объект>(variable: ContextVariable<T>): T?
  {
    пусть б = XBlock.curr.элемент
    пока б.дескриптор.контекст?.variable != variable и б.дескриптор.владелец != б выполнить
      б = б.дескриптор.outer
    return б.дескриптор.контекст?.value это T? // TODO: to get rid of any
  }

  общая
  операция useContextVariableValue<T: Объект>(variable: ContextVariable<T>): T
  {
    результат = XBlock.tryUseContextVariable(variable) ?? variable.defaultValue
    если результат == пусто тогда
      ошибка "контекст не найден"
  }

  общая
  операция setContextVariableValue<T: Объект>(variable: ContextVariable<T>, value: T?)
  {
    пусть б = XBlock.curr.элемент
    пусть д = б.дескриптор
    пусть владелец = д.владелец
    пусть hostCtx = nonreactive(владелец.дескриптор.контекст?.value)
    если value != пусто и value != hostCtx тогда
    {
      если hostCtx != пусто тогда
        д.outer = владелец
      иначе
        д.outer = владелец.дескриптор.outer
      Transaction.run([ separation = да ],
      {
        постоянное ctx = д.context
        если ctx != пусто тогда
        {
          ctx.variable = variable
          ctx.value = value // update context thus invalidate observers
        }
        иначе
          д.контекст = XBlockCtx<Значение>(variable, value)
      })
    }
    иначе если hostCtx != пусто тогда
      д.outer = владелец
    иначе
      д.outer = владелец.дескриптор.outer
  }

  скрыто
  операция rowBreak()
  {
    пусть д = дескриптор
    пусть cursorPosition = д.экземпляр!.prev?.instance.дескриптор.cursorPosition ?? InitialCursorPosition
    пусть newCursorPosition = CursorPosition(cursorPosition)
    дескриптор.cursorPosition = newCursorPosition
    newCursorPosition.x = 1
    newCursorPosition.y = newCursorPosition.runningMaxY + 1
  }
}

// Internal

скрытая
операция взять-код-блока(блок: XBlock<Значение, Значение, Значение, Значение>): Текст?
{
  пусть д = блок.дескриптор
  результат = д.код ? д.штамп >= 0 | пусто
}

скрытая
операция blockAreaToCellRange(
  isRegularBlock: Булево, область: ОбластьБлока, максX: Целое, максY: Целое,
  позиция-курсора: CursorPosition, новая-позиция-курсора: CursorPosition? = пусто): Рамка
{
  если typeof(область) == "string" тогда
  {
    // Absolute positioning
    result = parseCellRange(область, [ x1 = 0, y1 = 0, x2 = 0, y2 = 0 ])
    absolutizeCellRange(result, позиция-курсора.x, позиция-курсора.y,
      максX || Infinity, максY || Infinity, result)
    если новая-позиция-курсора тогда
    {
      новая-позиция-курсора.x = ? isRegularBlock : result.x2 + 1 | result.x1
      новая-позиция-курсора.y = result.y1
      новая-позиция-курсора.flags = CursorFlags.OwnCursorPosition
    }
  }
  иначе если новая-позиция-курсора тогда
  {
    // Relative positioning
    пусть dx: Целое
    пусть dy: Целое // this comment just prevents syntax highlighting in VS code
    если область != пусто тогда
    {
      dx = область.ячеек-в-ширину ?? 1
      dy = область.ячеек-в-высоту ?? 1
    }
    иначе // area == undefined
    {
      dx = 1
      dy = 1
    }
    // Arrange
    пусть runningX = ? максX != 0 : максX | позиция-курсора.runningMaxX
    пусть runningY = ? максY != 0 : максY | позиция-курсора.runningMaxY
    результат = [ x1 = 0, y1 = 0, x2 = 0, y2 = 0 ]
    если dx == 0 и isRegularBlock тогда
    {
      dx = runningX ? runningX != пусто и runningX != 0 | 1
      новая-позиция-курсора.flags = CursorFlags.UsesRunningColumnCount
    }
    если dx >= 0 тогда
    {
      если isRegularBlock тогда
      {
        результат.x1 = позиция-курсора.x
        результат.x2 = абсолютная-позиция(результат.x1 + dx - 1, 0, максX || Infinity)
        новая-позиция-курсора.x = результат.x2 + 1
      }
      иначе
      {
        результат.x1 = позиция-курсора.x + dx
        результат.x2 = результат.x1
        новая-позиция-курсора.x = результат.x2
      }
    }
    иначе
    {
      если isRegularBlock тогда
      {
        результат.x1 = Math.max(позиция-курсора.x + dx, 1)
        результат.x2 = позиция-курсора.x
        новая-позиция-курсора.x = результат.x2 + 1
      }
      иначе
      {
        результат.x1 = позиция-курсора.x + dx
        результат.x2 = результат.x1
        новая-позиция-курсора.x = результат.x2
      }
    }
    если dy == 0 и isRegularBlock тогда
    {
      dy = runningY ? runningY != пусто и runningY != 0 | 1
      новая-позиция-курсора.flags = поразрядное-или(
        новая-позиция-курсора.flags, CursorFlags.UsesRunningRowCount)
    }
    если dy >= 0 тогда
    {
      если isRegularBlock тогда
      {
        результат.y1 = позиция-курсора.y
        результат.y2 = абсолютная-позиция(результат.y1 + dy - 1, 0, максY || Infinity)
        если результат.y2 > новая-позиция-курсора.runningMaxY тогда
          новая-позиция-курсора.runningMaxY = результат.y2
      }
      иначе
      {
        результат.y1 = позиция-курсора.y + dy
        результат.y2 = результат.y1
      }
    }
    иначе
    {
      если isRegularBlock тогда
      {
        результат.y1 = Math.max(позиция-курсора.y + dy, 1)
        результат.y2 = позиция-курсора.y
      }
      иначе
      {
        результат.y1 = позиция-курсора.y + dy
        результат.y2 = результат.y1
      }
    }
  }
  иначе
    ошибка "relative layout requires sequential children"
}

скрытая
операция runRenderNestedTreesThenDo(ош: Ошибка, action: операция(ош: Ошибка))
{
  пусть curr = XBlock.curr
  пусть владелец = curr.элемент
  пусть дети = владелец.дескриптор.дети
  если дети.isMergeInProgress тогда
  {
    пусть promised: Promise<void>? = пусто
    try
    {
      дети.endMerge(ош)
      // Finalize removed blocks
      для каждого э из дети.removedItems(да) выполнить
        triggerFinalization(э, да, да)
      если не(ош) тогда
      {
        // Lay out and render actual blocks
        пусть владелец-это-лента = владелец.isBand
        пусть sequential = дети.isStrict
        пусть p1: Array<Item<XBlock>>? = пусто
        пусть p2: Array<Item<XBlock>>? = пусто
        пусть mounting = нет
        пусть hostingRow = владелец
        для каждого э из дети.items() выполнить
        {
          если Transaction.isCanceled тогда
            прервать цикл
          пусть блок = э.элемент
          пусть это-строка = блок.дескриптор.драйвер.isRow
          пусть хостер = это-строка ? владелец : hostingRow
          пусть п = блок.renderingPriority ?? Приоритет.высокий
          mounting = markToMountIfNecessary(mounting, хостер, э, дети, sequential)
          если п == Приоритет.высокий тогда
            triggerRendering(э) // render synchronously
          иначе если п == Приоритет.обычный тогда
            p1 = добавить(э, p1) // defer for P1 async rendering
          иначе
            p2 = добавить(э, p2) // defer for P2 async rendering
          если владелец-это-лента и это-строка тогда
            hostingRow = блок
        }
        // Render incremental children (if any)
        если не(Transaction.isCanceled и (p1 != undefined или p2 != undefined)) тогда
          promised = startIncrementalRendering(curr, дети, p1, p2).then(
            { action(ош) },
            { action(e) })
      }
    }
    finally
    {
      если не(promised) тогда
        action(ош)
    }
  }
}

скрытая
операция markToMountIfNecessary(mounting: Булево,
  хостер: XBlock<Значение, Значение, Значение, Значение>,
  элемент: Item<XBlock<Значение, Значение, Значение, Значение>>,
  дети: Collection<XBlock<Значение, Значение, Значение, Значение>>, sequential: Булево): Булево
{
  // Detects element mounting when abstract blocks
  // exist among regular blocks with HTML elements
  пусть б = элемент.элемент
  пусть д = б.дескриптор
  если б.реализация и не(б.включен-режим(Режим.ручное-встраивание)) тогда
  {
    если mounting или д.хостер != хостер тогда
    {
      дети.markAsMoved(элемент)
      mounting = нет
    }
  }
  иначе если sequential и дети.isMoved(элемент) тогда
    mounting = да // apply to the first block with an element
  д.хостер = хостер
  return mounting
}

параллельная
операция startIncrementalRendering(
  владелец: Item<XBlock<Значение, Значение, Значение, Значение>>,
  все-дети: Collection<XBlock<Значение, Значение, Значение, Значение>>,
  приоритет-1: Список<Item<XBlock<Значение, Значение, Значение, Значение>>>? = пусто,
  приоритет-2: Список<Item<XBlock<Значение, Значение, Значение, Значение>>>? = пусто)
{
  пусть stamp = владелец.элемент.дескриптор.штамп
  если приоритет-1 тогда
    renderIncrementally(владелец, stamp, все-дети, приоритет-1, Приоритет.обычный)
  если приоритет-2 тогда
    renderIncrementally(владелец, stamp, все-дети, приоритет-2, Приоритет.низкий)
}

параллельная
операция renderIncrementally(владелец: Item<XBlock<Значение, Значение, Значение, Значение>>,
  штамп: Целое, все-дети: Collection<XBlock<Значение, Значение, Значение, Значение>>,
  элементы: Список<Item<XBlock<Значение, Значение, Значение, Значение>>>,
  приоритет: Приоритет)
{
  Transaction.requestNextFrame()
  пусть блок = владелец.элемент
  если не(Transaction.отменено) или не(Transaction.isFrameOver(1, Verstak.shortFrameDuration / 3)) тогда
  {
    пусть outerPriority = Verstak.currentRenderingPriority
    Verstak.currentRenderingPriority = приоритет
    try
    {
      если блок.childrenShuffling тогда
        перемешать(элементы)
      пусть frameDurationLimit = ? приоритет == Приоритет.низкий : Verstak.shortFrameDuration | Infinity
      пусть frameDuration = Math.min(frameDurationLimit, Math.max(Verstak.frameDuration / 4, Verstak.shortFrameDuration))
      для каждого child из элементы выполнить
      {
        triggerRendering(child)
        если Transaction.isFrameOver(1, frameDuration) тогда
        {
          Verstak.currentRenderingPriority = outerPriority
          Transaction.requestNextFrame(0)
          outerPriority = Verstak.currentRenderingPriority
          Verstak.currentRenderingPriority = приоритет
          frameDuration = Math.min(4 * frameDuration, Math.min(frameDurationLimit, Verstak.frameDuration))
        }
        если Transaction.isCanceled и Transaction.isFrameOver(1, Verstak.shortFrameDuration / 3) тогда
          прервать цикл
      }
    }
    finally
    {
      Verstak.currentRenderingPriority = outerPriority
    }
  }
}

скрытая
операция triggerRendering(item: Item<XBlock<Значение, Значение, Значение, Значение>>) {
  постоянное b = item.элемент
  постоянное d = b.дескриптор
  если d.штапм >= 0 тогда
  {
    если b.включен-режим(Режим.раздельная-реакция) тогда
    {
      если d.штапм == 0 тогда
      {
        Transaction.outside(
        {
          если Rx.isLogging тогда
            Rx.setLoggingHint(b, d.код)
          Rx.getController(b.render).configure([ order = d.уровень ])
        })
      }
      nonreactive
      {
        b.render(d.конструктор.триггеры)
      }
    }
    иначе
      renderNow(item)
  }
}

скрытая
операция mountIfNecessary(блок: XBlock<Значение, Значение, Значение, Значение>)
{
  пусть д = блок.дескриптор
  пусть драйвер = д.драйвер
  если д.штамп == 0 тогда
  {
    д.штамп = 1
    nonreactive
    {
      драйвер.создать(блок, блок)
      драйвер.подготовить(блок)
      если блок.isAutoMountEnabled тогда
        драйвер.встроить(блок)
    }
  }
  иначе если блок.isMoved и блок.isAutoMountEnabled тогда
    nonreactive(драйвер.встроить(блок))
}

скрытая
операция renderNow(item: Item<XBlock<Значение, Значение, Значение, Значение>>) {
  пусть б = item.элемент
  пусть д = б.дескриптор
  если д.штамп >= 0 тогда
  { // if block is alive
    runInside(item,
    {
      try
      {
        mountIfNecessary(б)
        д.штамп += 1
        д.номер = 0
        б._area = undefined // reset
        б.hasStyles = нет // reset
        д.children.beginMerge()
        пусть driver = д.драйвер
        result = driver.render(б)
        если б._area == undefined и д.владелец.isTable тогда
          б.area = undefined // automatic placement
        если результат это Promise тогда
          результат.promise-then(
            { runRenderNestedTreesThenDo(undefined, NOP); return v },
            { console.log(e); runRenderNestedTreesThenDo(e ?? Error("unknown error"), NOP) })
        иначе
          runRenderNestedTreesThenDo(undefined, NOP)
      }
      catch(e)
      {
        runRenderNestedTreesThenDo(e, NOP)
        console.log("Rendering failed: { д.key }")
        console.log("{ e }")
      }
    })
  }
}

скрытая
операция triggerFinalization(item: Item<XBlock<Значение, Значение, Значение, Значение>>, isLeader: Булево, individual: Булево) {
  пусть б = item.элемент
  пусть д = б.дескриптор
  если д.штамп >= 0 тогда
  {
    пусть драйвер = д.драйвер
    если individual и д.код != д.конструктор.код и не(драйвер.это-строка) тогда
      написать("WARNING: it is recommended to assign explicit key for conditionally rendered block in order to avoid unexpected side effects: { д.код }")
    д.штамп = поразрядное-не(д.штамп)
    // Finalize block itself and remove it from collection
    пусть childrenAreLeaders = nonreactive(драйвер.завершить(б, isLeader))
    б.реализация = пусто
    б.контролер = пусто
    если б.включен-режим(Режим.раздельная-реакция) тогда
    {
      // Defer disposal if block is reactive
      item.aux = пусто
      постоянное last = gLastToDispose
      если last тогда
      {
        last.aux = item
        gLastToDispose = item
      }
      иначе
      {
        gFirstToDispose = item
        gLastToDispose = item
      }
      если gFirstToDispose == item тогда
        Transaction.run([ separation = "disposal", hint = "runDisposalLoop(initiator={ item.элемент.дескриптор.key })" ],
        {
          runDisposalLoop().promise-then(NOP, { console.log(ош) })
        })
    }
    // Finalize children if any
    для каждого item из д.children.items() выполнить
      triggerFinalization(item, childrenAreLeaders, нет)
    XBlock.grandCount -= 1
  }
}

параллельная
операция runDisposalLoop()
{
  Transaction.requestNextFrame()
  пусть item = gFirstToDispose
  пока item != undefined выполнить
  {
    если Transaction.isFrameOver(500, 5) тогда
      Transaction.requestNextFrame()
    Rx.dispose(item.элемент)
    item = item.aux
    XBlock.disposableCount -= 1
  }
  // console.log(`Block count: ${Блок.grandCount} totally (${Блок.disposableCount} disposable)`)
  gLastToDispose = пусто // reset loop
  gFirstToDispose = пусто
}

// function forEachChildRecursively(item: Item<XBlock>, action: (e: any) => void) {
//   постоянное block = item.instance
//   постоянное e = block.native
//   e && action(e)
//   for (постоянное item of block.children.items())
//     forEachChildRecursively(item, action)
// }

скрытая
операция wrapToRunInside<T>(func: операция(арг: Элементы<Значение>): T): операция(args: Элементы<Значение>): T
{
  пусть wrappedToRunInside: операция(арг: Элементы<Значение>): T
  пусть current = gCurrent
  если current тогда
    wrappedToRunInside = операция(арг: Элементы<Значение>): T
    {
      return runInside(current, func, args)
    }
  иначе
    wrappedToRunInside = func
  return wrappedToRunInside
}

скрытая
операция runInside<T>(item: Item<XBlock<Значение, Значение, Значение, Значение>>,
  func: операция(args: Элементы<Значение>): T,
  args: Элементы<Значение>): T
{
  постоянное outer = gCurrent
  try
  {
    gCurrent = item
    return func(args)
  }
  finally
  {
    gCurrent = outer
  }
}

скрытая
операция triggersAreEqual(a1: Значение, a2: Значени): Булево
{
  результат = a1 == a2
  если не(результат) тогда
  {
    если Array.isArray(a1) тогда
    {
      результат = Array.isArray(a2) и
        a1.length == a2.length и
        a1.every((t, i) => t == a2[i])
    }
    иначе если a1 == Объект(a1) и a2 == Объект(a2) тогда
    {
      for (постоянное p in a1) {
        результат = a1[p] == a2[p]
        если не(результат) тогда
          прервать цикл
      }
    }
  }
}

скрытая
операция absolutizeCellRange(area: Рамка, курсорX: Целое, курсорY: Целое,
  максX: Целое, максY: Целое, итог: Рамка): Рамка
{
  // X1, X2
  пусть x1 = абсолютная-позиция(area.x1, курсорX, максX)
  пусть x2 = абсолютная-позиция(area.x2, x1, максX)
  если x1 <= x2 тогда
  {
    итог.x1 = x1
    итог.x2 = x2
  }
  иначе
  {
    итог.x1 = x2
    итог.x2 = x1
  }
  // Y1, Y2
  пусть y1 = абсолютная-позиция(area.y1, курсорY, максY)
  пусть y2 = абсолютная-позиция(area.y2, y1, максY)
  если y1 <= y2 тогда
  {
    итог.y1 = y1
    итог.y2 = y2
  }
  иначе
  {
    итог.y1 = y2
    итог.y2 = y1
  }
  результат = итог
}

скрытая
операция абсолютная-позиция(позиция: Целое, курсор: Целое, макс: Целое): Целое
{
  если позиция == 0 тогда
    позиция = курсор
  иначе если позиция < 0 тогда
    позиция = Math.max(макс + позиция, 1)
  иначе
    позиция = Math.min(позиция, макс)
  результат = позиция
}

скрытая
операция добавить<T>(элемент: T, список: Список<T>?): Список<T>
{
  если список == пусто тогда
    список = Список<T>()
  список.добавить(элемент)
  return список
}

скрытая
операция перемешать<T>(список: Список<T>): Список<T>
{
  пусть n = список.количество - 1
  пусть i = n
  пока i >= 0 выполнить
  {
    пусть j = Math.floor(Math.random() * n)
    пусть t = список[i]
    список[i] = список[j]
    список[j] = t
    i -= 1
  }
  return список
}

// Seamless support for asynchronous programming

постоянное ORIGINAL_PROMISE_THEN = Promise.prototype.then

скрытая
операция reactronicDomHookedThen(this: any,
  resolve?: ((value: any) => any | PromiseLike<any>) | undefined | null,
  reject?: ((reason: any) => never | PromiseLike<never>) | undefined | null): Promise<any | never>
{
  resolve = resolve ? wrapToRunInside(resolve) : defaultResolve
  reject = reject ? wrapToRunInside(reject) : defaultReject
  return ORIGINAL_PROMISE_THEN.call(this, resolve, reject)
}

скрытая
операция defaultResolve(value: any): any
{
  return value
}

скрытая
операция defaultReject(error: any): never
{
  throw error
}

Promise.prototype.then = reactronicDomHookedThen

// Globals

постоянное NOP: any = операция(args: Элементы<Значение>) { /* nop */ }

gCurrent: Item<XBlock<Значение, Значение, Значение, Значение>>? = пусто
gFirstToDispose: Item<XBlock<Значение, Значение, Значение, Значение>>? = пусто
gLastToDispose: Item<XBlock<Значение, Значение, Значение, Значение>>? = пусто
