// The below copyright notice and the license permission notice
// shall be included in all copies or substantial portions.
// Copyright (C) 2019-2022 Nezaboodka Software <contact@nezaboodka.com>
// License: https://raw.githubusercontent.com/nezaboodka/verstak/master/LICENSE
// By contributing, you agree that your contributions will be
// automatically licensed under the license referred above.

используется артель

операция текст-в-рамку(текст: Текст, рамка: Рамка): Рамка
{
  пусть i = 0
  пусть знач = 0
  пусть знак = 1
  пусть компонент = 0
  пока i < текст.длина выполнить
  {
    пусть код-символа = текст[i]
    если это-заглавная-буква(код-символа) тогда
    {
      если компонент % 2 == 0 тогда
        знач = знач * 26 + код-символа - 64
      иначе
        ошибка "Digit is expected, but letter ('{ текст[i] }') was read"
    }
    иначе если это-строчная-буква(код-символа) тогда
    {
      если компонент % 2 == 0 тогда
        знач = знач * 26 + код-символа - 96
      иначе
        ошибка "Digit is expected, but letter ('${текст[i]}') was read"
    }
    иначе если это-цифра(код-символа) тогда
    {
      если компонент % 2 == 0 тогда
      {
        если знач != 0 тогда
        {
          если компонент == 0 тогда
            результат.x1 = знач * знак
          иначе
            результат.x2 = знач * знак
          знач = 0
        }
        компонент += 1
      }
      знач = знач * 10 + код-символа - 48
    }
    иначе если код-символа == 40 тогда
    { // (
      если компонент == 0 тогда
        результат.x1 = знач * знак
      иначе если компонент == 2 тогда
        результат.x2 = знач * знак
      если знак > 0 тогда
      {
        знак = -1
        компонент &= ~1
        знач = 0
      }
      иначе
        ошибка "Sign must not be negative"
    }
    иначе если код-символа == 41 тогда
    { // )
      если знак > 0 тогда
        ошибка "Sign must be negative"
      выбор компонент
      либо 0: результат.x1 = знач * знак
      либо 1: результат.y1 = знач * знак
      либо 2: результат.x2 = знач * знак
      либо 3: результат.y2 = знач * знак
      знак = 1
      знач = 0
      компонент += 1
    }
    иначе если код-символа == 58 тогда
    { // :
      если знак < 0 тогда
        ошибка "area '${ текст }': e1"
      если компонент == 1 тогда
        результат.y1 = знач * знак
      иначе если компонент != 2 тогда
        ошибка "area '${ текст }': [e2] компонент = ${ компонент }"
      компонент = 2
      знач = 0
    }
    иначе если это-пробел(код-символа) тогда
    {
      /* nop */
    }
    иначе
      ошибка "Unknown symbol '${текст[i]}' in '${текст}'"
    i += 1
  }
  если знач != 0 тогда
  {
    выбор компонент
    либо 0:
    {
      результат.x1 = знач * знак
      если знак < 0 и результат.y1 == 0 тогда
        результат.y1 = знак
    }
    либо 1:
    {
      если знак < 0 и результат.x1 == 0 тогда
        результат.x1 = знак
      результат.y1 = знач * знак
    }
    либо 2:
    {
      результат.x2 = знач * знак
      если знак < 0 и результат.y2 == 0 тогда
        результат.y2 = знак
    }
    либо 3:
    {
      если знак < 0 и результат.x2 == 0 тогда
        результат.x2 = знак
      результат.y2 = знач * знак
    }
  }
  иначе если знак < 0 тогда
  {
    если компонент == 0 тогда
    {
      если результат.x1 == 0 тогда
        результат.x1 = знак
      если результат.y1 == 0 тогда
        результат.y1 = знак
    }
    else
    {
      если результат.x2 == 0 тогда
        результат.x2 = знак
      если результат.y2 == 0 тогда
        результат.y2 = знак
    }
  }
}

операция рамка-в-текст(value: Рамка): Текст
{
  const p1 = позиция-в-текст(value.x1, value.y1)
  const p2 = позиция-в-текст(value.x2, value.y2)
  return "{p1}{? p2 != "" : ":{p2}" | ""}"
}

операция целое-в-букву(n: Целое): Текст
{
  если n < 0 тогда
    ошибка "целое-в-букву: argument ({ n }) should not be negative or zero"
  результат = ""
  пока n >= 0 выполнить
  {
    пусть r = n % 26
    n = Math.floor(n / 26) - 1
    результат = String.fromCharCode(65 + r) + результат
  }
}

операция позиция-в-текст(x: Целое, y: Целое): Текст
{
  если x > 0 и y > 0 тогда
    результат = "{ целое-в-букву(x - 1) }{ y }"
  иначе если x > 0 и y < 0 тогда
    результат = "{ целое-в-букву(x - 1) }({ -y })"
  иначе если x < 0 и y > 0 тогда
    результат = "({ целое-в-букву(-x - 1) }){ y }"
  иначе если x < 0 и y < 0 тогда
    результат = "({ целое-в-букву(-x - 1) }{ -y })"
  иначе
    результат = ""
}

операция рамки-идентичны(р1: Рамка, р2: Рамка): Булево
{
  return р1.x1 == р2.x1 и
    р1.y1 == р2.y1 и
    р1.x2 == р2.x2 и
    р1.y1 == р2.y2
}

скрытая
операция это-пробел(сим: Символ): Булево
{
  // only latin white spaces are supported
  return сим == 32
    или (сим >= 9 и сим <= 13)
    или сим == 13
    или сим == 160
}

скрытая
операция это-цифра(сим: Символ): Булево
{
  return 48 <= сим и сим <= 57
}

скрытая
операция это-заглавная-буква(сим: Символ): Булево
{
  return 65 <= сим и сим <= 90
}

скрытая
операция это-строчная-буква(сим: Символ): Булево
{
  return 97 <= сим и сим <= 122
}

операция objectHasMember<T>(obj: Значение, member: Текст): T
{
  результат = obj == Object(obj) и не(Array.isArray(obj)) // и member in obj
}

операция getCallerInfo(prefix: Текст): Текст
{
  // const restore = Error.stackTraceLimit = 20
  // const error = new Error()
  // const stack = error.stack || ""
  // Error.stackTraceLimit = restore
  // const lines = stack.split("\n")
  // let i = lines.findIndex(x => x.indexOf(".claim") >= 0)
  // i = i >= 0 ? i + 2 : 5
  // let caller = extractFunctionAndLocation(lines[i])
  // let location = caller
  // if (caller.func.endsWith(".render"))
  // {
  //   i = i - 1
  //   caller = extractFunctionAndLocation(lines[i])
  //   location = extractFunctionAndLocation(lines[i + 1])
  // }
  // else
  // {
  //   while (!caller.func и i > 0)
  //   {
  //     i = i - 1
  //     caller = extractFunctionAndLocation(lines[i])
  //   }
  //   location = extractFunctionAndLocation(lines[i + 1])
  // }
  // const результат = `${prefix}·${caller.func}@${location.file}`
  // return результат
}

скрытая
операция extractFunctionAndLocation(s: Текст): объект { func: Текст; file: Текст }
{
  // // const match = s.match(/(?:\s*at\s+)?(?:\S+\s\(|@)?(?:.*?)([^\/\(\):]+)(?:(:|\d)*\)?)$/)
  // const match = s.match(/(?:\s*at\s+)?(?:(\S+)\s\()?(?:.*?)([^\/\(\):]+)(?:(:|\d)*\)?)$/)
  // return {
  //   func: match?.[1] || "",
  //   file: match?.[2] || "",
  // }
}
